<epics>
  <epic_and_tickets>
    <epic>
      <title>Artifact Type Management</title>
      <user_story>As a developer, I want to manage artifact types through a RESTful API so that I can dynamically configure and update artifact processing in the LAPS system.</user_story>
      <description>Implement CRUD operations for artifact types, allowing for the creation, retrieval, updating, and deletion of artifact types. This feature will enable dynamic configuration of artifact processing, improving system flexibility and reducing the need for code changes when new artifact types are introduced.</description>
      <technical_details>This epic involves creating new API endpoints for artifact type management, integrating with the Alloy client for validation, implementing caching using Redis, and persisting data in the LAPS database. Key considerations include:
            - Implementing proper authentication and authorization using S2S tokens
            - Ensuring data consistency between cache and database
            - Handling potential race conditions in concurrent operations
            - Optimizing database queries for performance
            - Implementing proper error handling and logging</technical_details>
      <affected_components>
        <component>LAPS API</component>
        <component>Cache Layer</component>
        <component>Database Layer</component>
        <component>Alloy Integration</component>
      </affected_components>
    </epic>
    <tickets>
      <ticket>
        <title>Create Artifact Type API</title>
        <user_story>As a developer, I want to create new artifact types through an API so that I can dynamically add new types of artifacts to be processed by the system.</user_story>
        <acceptance_criteria>
          <criterion>The API endpoint POST {LAPS_BASE_URL}/artifact-type is implemented and accessible</criterion>
          <criterion>The endpoint requires valid S2S Bearer token authentication</criterion>
          <criterion>The endpoint accepts all required fields in the request payload</criterion>
          <criterion>The artifact type is validated against the Alloy response</criterion>
          <criterion>The new artifact type is added to the Redis cache</criterion>
          <criterion>The new artifact type is persisted in the LAPS database</criterion>
          <criterion>Appropriate success and error responses are returned</criterion>
        </acceptance_criteria>
        <description>Implement a new API endpoint for creating artifact types. This endpoint will validate the artifact type against the Alloy response, add it to the cache, and persist it in the database.</description>
        <affected_files>
          <file>src/routes/artifact-types/create-artifact-type/handler.ts</file>
          <file>src/services/artifact-type/service.ts</file>
          <file>src/orm/repositories/artifact-type/repository.ts</file>
          <file>src/clients/alloy/client.ts</file>
        </affected_files>
        <steps>
          <step>Create a new route handler file for the create artifact type endpoint</step>
          <step>Implement request payload validation</step>
          <step>Create a new method in the Alloy client for fetching and validating artifact types</step>
          <step>Implement caching logic for new artifact types</step>
          <step>Create a new method in the ArtifactTypeRepository for database persistence</step>
          <step>Implement error handling and logging</step>
          <step>Write unit tests for the new endpoint and related functions</step>
          <step>Update API documentation</step>
        </steps>
        <dependencies>Cache implementation, Database schema update</dependencies>
        <risks_and_challenges>Ensuring data consistency between cache and database, handling potential high concurrency</risks_and_challenges>
        <estimated_complexity>Medium</estimated_complexity>
        <priority>High</priority>
        <effort>13</effort>
        <effortIn>story points</effortIn>
      </ticket>
      <ticket>
        <title>Update Artifact Type API</title>
        <user_story>As a developer, I want to update existing artifact types through an API so that I can modify artifact type configurations as requirements change.</user_story>
        <acceptance_criteria>
          <criterion>The API endpoint PUT {LAPS_BASE_URL}/artifact-type is implemented and accessible</criterion>
          <criterion>The endpoint requires valid S2S Bearer token authentication</criterion>
          <criterion>The endpoint accepts the artifactTypeId and fields to update in the request payload</criterion>
          <criterion>The updated artifact type is validated against the Alloy response</criterion>
          <criterion>The artifact type is updated in the Redis cache</criterion>
          <criterion>The artifact type is updated in the LAPS database</criterion>
          <criterion>Appropriate success and error responses are returned</criterion>
        </acceptance_criteria>
        <description>Implement a new API endpoint for updating artifact types. This endpoint will validate the updated artifact type against the Alloy response, update it in the cache, and persist the changes in the database.</description>
        <affected_files>
          <file>src/routes/artifact-types/update-artifact-type/handler.ts</file>
          <file>src/services/artifact-type/service.ts</file>
          <file>src/orm/repositories/artifact-type/repository.ts</file>
          <file>src/clients/alloy/client.ts</file>
        </affected_files>
        <steps>
          <step>Create a new route handler file for the update artifact type endpoint</step>
          <step>Implement request payload validation</step>
          <step>Create a new method in the ArtifactTypeService for updating artifact types</step>
          <step>Implement cache update logic</step>
          <step>Create a new method in the ArtifactTypeRepository for database updates</step>
          <step>Implement error handling and logging</step>
          <step>Write unit tests for the new endpoint and related functions</step>
          <step>Update API documentation</step>
        </steps>
        <dependencies>Create Artifact Type API</dependencies>
        <risks_and_challenges>Handling concurrent updates, ensuring data consistency across cache and database</risks_and_challenges>
        <estimated_complexity>Medium</estimated_complexity>
        <priority>High</priority>
        <effort>8</effort>
        <effortIn>story points</effortIn>
      </ticket>
      <ticket>
        <title>Delete Artifact Type API</title>
        <user_story>As a developer, I want to delete artifact types through an API so that I can remove obsolete or unnecessary artifact types from the system.</user_story>
        <acceptance_criteria>
          <criterion>The API endpoint DEL {LAPS_BASE_URL}/artifact-type is implemented and accessible</criterion>
          <criterion>The endpoint requires valid S2S Bearer token authentication</criterion>
          <criterion>The endpoint accepts the artifactTypeId in the request payload</criterion>
          <criterion>The artifact type is removed from the Redis cache</criterion>
          <criterion>The artifact type is soft deleted in the LAPS database</criterion>
          <criterion>Appropriate success and error responses are returned</criterion>
        </acceptance_criteria>
        <description>Implement a new API endpoint for deleting artifact types. This endpoint will remove the artifact type from the cache and perform a soft delete in the database.</description>
        <affected_files>
          <file>src/routes/artifact-types/delete-artifact-type/handler.ts</file>
          <file>src/services/artifact-type/service.ts</file>
          <file>src/orm/repositories/artifact-type/repository.ts</file>
        </affected_files>
        <steps>
          <step>Create a new route handler file for the delete artifact type endpoint</step>
          <step>Implement request payload validation</step>
          <step>Create a new method in the ArtifactTypeService for deleting artifact types</step>
          <step>Implement cache removal logic</step>
          <step>Create a new method in the ArtifactTypeRepository for database soft deletes</step>
          <step>Implement error handling and logging</step>
          <step>Write unit tests for the new endpoint and related functions</step>
          <step>Update API documentation</step>
        </steps>
        <dependencies>Create Artifact Type API</dependencies>
        <risks_and_challenges>Ensuring no data inconsistencies are introduced by deleting artifact types, handling potential cascading deletes</risks_and_challenges>
        <estimated_complexity>Low</estimated_complexity>
        <priority>Medium</priority>
        <effort>5</effort>
        <effortIn>story points</effortIn>
      </ticket>
      <ticket>
        <title>Retrieve Artifact Types API</title>
        <user_story>As a developer, I want to retrieve artifact types through an API so that I can view and manage the existing artifact types in the system.</user_story>
        <acceptance_criteria>
          <criterion>The API endpoint GET {LAPS_BASE_URL}/artifact-type is implemented and accessible</criterion>
          <criterion>The endpoint requires valid S2S Bearer token authentication</criterion>
          <criterion>The endpoint returns a list of all non-deleted artifact types with their related data</criterion>
          <criterion>The response includes all relevant details for each artifact type</criterion>
          <criterion>Appropriate success and error responses are returned</criterion>
        </acceptance_criteria>
        <description>Implement a new API endpoint for retrieving artifact types. This endpoint will fetch all non-deleted artifact types from the database and return them with their related data.</description>
        <affected_files>
          <file>src/routes/artifact-types/get-artifact-types/handler.ts</file>
          <file>src/services/artifact-type/service.ts</file>
          <file>src/orm/repositories/artifact-type/repository.ts</file>
        </affected_files>
        <steps>
          <step>Create a new route handler file for the get artifact types endpoint</step>
          <step>Create a new method in the ArtifactTypeService for retrieving artifact types</step>
          <step>Create a new method in the ArtifactTypeRepository for querying the database</step>
          <step>Implement data aggregation and transformation logic</step>
          <step>Implement error handling and logging</step>
          <step>Write unit tests for the new endpoint and related functions</step>
          <step>Update API documentation</step>
        </steps>
        <dependencies>Database schema update</dependencies>
        <risks_and_challenges>Handling potentially large datasets, optimizing query performance</risks_and_challenges>
        <estimated_complexity>Low</estimated_complexity>
        <priority>Medium</priority>
        <effort>5</effort>
        <effortIn>story points</effortIn>
      </ticket>
    </tickets>
  </epic_and_tickets>
  <epic_and_tickets>
    <epic>
      <title>Catalog Management</title>
      <user_story>As a developer, I want to manage catalog components (workflow_names, artifact_groups, journeys) through CRUD operations so that I can maintain and update the artifact processing system efficiently.</user_story>
      <description>Implement a set of RESTful APIs to create, read, update, and delete catalog components in the LAPS (Lending Artifact Processing Service) system. This feature will enable efficient management of workflow names, artifact groups, and journeys, which are essential for artifact type processing and organization.</description>
      <technical_details>The implementation will involve creating new API endpoints for each CRUD operation, updating the database schema to support the new catalog components, and ensuring proper authentication and error handling. The feature will use the existing microservice-chassis framework and follow RESTful conventions. All endpoints will be secured with S2S authentication using bearer tokens.</technical_details>
      <affected_components>
        <component>LAPS API</component>
        <component>LAPS Database</component>
        <component>Authentication System</component>
      </affected_components>
    </epic>
    <tickets>
      <ticket>
        <title>Create Catalog Component API</title>
        <user_story>As a developer, I want to create new catalog components via an API so that I can add new workflow names, artifact groups, or journeys to the system.</user_story>
        <acceptance_criteria>
          <criterion>The API should accept POST requests to create new catalog components</criterion>
          <criterion>The endpoint should be secured with S2S authentication using bearer tokens</criterion>
          <criterion>The API should validate input data and return appropriate error messages for invalid requests</criterion>
          <criterion>Successfully created components should be persisted in the database</criterion>
          <criterion>The API should return a success message with the created component details</criterion>
        </acceptance_criteria>
        <description>Implement a POST endpoint that allows creation of new catalog components (workflow_names, artifact_groups, journeys). The API should validate input, persist the new component in the database, and return appropriate responses.</description>
        <affected_files>
          <file>src/routes/catalog/create-component/handler.ts</file>
          <file>src/routes/catalog/create-component/chassis-plugin.ts</file>
          <file>src/orm/repositories/workflow/repository.ts</file>
          <file>src/orm/repositories/artifact-group/repository.ts</file>
          <file>src/orm/repositories/journey/repository.ts</file>
          <file>schema/sql/V2024_07_01__add_catalog_component_tables.sql</file>
        </affected_files>
        <steps>
          <step>Create new route handler for POST /catalog/{component}</step>
          <step>Implement input validation logic</step>
          <step>Create new repository methods for inserting components</step>
          <step>Update database schema with new tables</step>
          <step>Implement error handling and response formatting</step>
          <step>Add unit tests for the new endpoint and repository methods</step>
          <step>Update API documentation</step>
        </steps>
        <dependencies>Database schema update</dependencies>
        <risks_and_challenges>Ensuring consistency across different component types, handling potential conflicts with existing data</risks_and_challenges>
        <estimated_complexity>Low</estimated_complexity>
        <priority>High</priority>
        <effort>13</effort>
        <effortIn>story points</effortIn>
      </ticket>
      <ticket>
        <title>Update Catalog Component API</title>
        <user_story>As a developer, I want to update existing catalog components via an API so that I can modify workflow names, artifact groups, or journeys in the system.</user_story>
        <acceptance_criteria>
          <criterion>The API should accept PUT requests to update existing catalog components</criterion>
          <criterion>The endpoint should be secured with S2S authentication using bearer tokens</criterion>
          <criterion>The API should validate input data and return appropriate error messages for invalid requests</criterion>
          <criterion>Successfully updated components should be persisted in the database</criterion>
          <criterion>The API should return a success message with the updated component details</criterion>
        </acceptance_criteria>
        <description>Implement a PUT endpoint that allows updating of existing catalog components (workflow_names, artifact_groups, journeys). The API should validate input, update the component in the database, and return appropriate responses.</description>
        <affected_files>
          <file>src/routes/catalog/update-component/handler.ts</file>
          <file>src/routes/catalog/update-component/chassis-plugin.ts</file>
          <file>src/orm/repositories/workflow/repository.ts</file>
          <file>src/orm/repositories/artifact-group/repository.ts</file>
          <file>src/orm/repositories/journey/repository.ts</file>
        </affected_files>
        <steps>
          <step>Create new route handler for PUT /catalog/{component}</step>
          <step>Implement input validation logic</step>
          <step>Create new repository methods for updating components</step>
          <step>Implement error handling and response formatting</step>
          <step>Add unit tests for the new endpoint and repository methods</step>
          <step>Update API documentation</step>
        </steps>
        <dependencies>Create Catalog Component API</dependencies>
        <risks_and_challenges>Handling concurrent updates, ensuring data integrity across related components</risks_and_challenges>
        <estimated_complexity>Low</estimated_complexity>
        <priority>High</priority>
        <effort>8</effort>
        <effortIn>story points</effortIn>
      </ticket>
      <ticket>
        <title>Retrieve Catalog Components API</title>
        <user_story>As a developer, I want to retrieve catalog components via an API so that I can view existing workflow names, artifact groups, or journeys in the system.</user_story>
        <acceptance_criteria>
          <criterion>The API should accept GET requests to retrieve catalog components</criterion>
          <criterion>The endpoint should be secured with S2S authentication using bearer tokens</criterion>
          <criterion>The API should return a list of components for the specified type</criterion>
          <criterion>The API should handle errors gracefully and return appropriate error messages</criterion>
        </acceptance_criteria>
        <description>Implement a GET endpoint that allows retrieval of catalog components (workflow_names, artifact_groups, journeys). The API should fetch components from the database and return them in a structured format.</description>
        <affected_files>
          <file>src/routes/catalog/get-components/handler.ts</file>
          <file>src/routes/catalog/get-components/chassis-plugin.ts</file>
          <file>src/orm/repositories/workflow/repository.ts</file>
          <file>src/orm/repositories/artifact-group/repository.ts</file>
          <file>src/orm/repositories/journey/repository.ts</file>
        </affected_files>
        <steps>
          <step>Create new route handler for GET /catalog/{component}</step>
          <step>Implement repository methods for fetching components with pagination</step>
          <step>Implement error handling and response formatting</step>
          <step>Add database indexes for performance optimization</step>
          <step>Add unit tests for the new endpoint and repository methods</step>
          <step>Update API documentation</step>
        </steps>
        <dependencies>Database schema update</dependencies>
        <risks_and_challenges>Handling large datasets efficiently, ensuring consistent performance as the number of components grows</risks_and_challenges>
        <estimated_complexity>Low</estimated_complexity>
        <priority>High</priority>
        <effort>8</effort>
        <effortIn>story points</effortIn>
      </ticket>
      <ticket>
        <title>Delete Catalog Component API</title>
        <user_story>As a developer, I want to delete catalog components via an API so that I can remove obsolete workflow names, artifact groups, or journeys from the system.</user_story>
        <acceptance_criteria>
          <criterion>The API should accept DELETE requests to remove catalog components</criterion>
          <criterion>The endpoint should be secured with S2S authentication using bearer tokens</criterion>
          <criterion>The API should validate the component_id and return appropriate error messages for invalid requests</criterion>
          <criterion>Successfully deleted components should be soft-deleted in the database</criterion>
          <criterion>The API should return a success message after deletion</criterion>
        </acceptance_criteria>
        <description>Implement a DELETE endpoint that allows removal of catalog components (workflow_names, artifact_groups, journeys). The API should validate input, soft-delete the component in the database, and return appropriate responses.</description>
        <affected_files>
          <file>src/routes/catalog/delete-component/handler.ts</file>
          <file>src/routes/catalog/delete-component/chassis-plugin.ts</file>
          <file>src/orm/repositories/workflow/repository.ts</file>
          <file>src/orm/repositories/artifact-group/repository.ts</file>
          <file>src/orm/repositories/journey/repository.ts</file>
          <file>src/orm/models/base-model/model.ts</file>
        </affected_files>
        <steps>
          <step>Create new route handler for DELETE /catalog/{component}</step>
          <step>Implement input validation logic</step>
          <step>Create new repository methods for soft-deleting components</step>
          <step>Implement dependency checking before deletion</step>
          <step>Update BaseModel to include soft delete functionality</step>
          <step>Implement error handling and response formatting</step>
          <step>Add unit tests for the new endpoint and repository methods</step>
          <step>Update API documentation</step>
        </steps>
        <dependencies>Create Catalog Component API</dependencies>
        <risks_and_challenges>Ensuring all related data is properly handled during deletion, preventing unintended data loss</risks_and_challenges>
        <estimated_complexity>Low</estimated_complexity>
        <priority>Medium</priority>
        <effort>13</effort>
        <effortIn>story points</effortIn>
      </ticket>
    </tickets>
  </epic_and_tickets>
  <epic_and_tickets>
    <epic>
      <title>Caching Implementation for LAPS</title>
      <user_story>As a LAPS developer, I want to implement Redis caching for artifact types and artifacts so that we can improve system performance and reduce database load.</user_story>
      <description>Implement Redis caching for artifact types and artifacts in the Lending Artifacts Processing Service (LAPS) to improve data retrieval speed and reduce database load. This will involve setting up Redis cache, implementing a cache-aside strategy, and creating separate caching mechanisms for artifact types and artifacts.</description>
      <technical_details>The implementation will use Redis as the caching system, integrated with the existing LAPS architecture. We&apos;ll create a cache manager to handle cache operations, implement specific caching structures for artifact types and artifacts, and ensure consistency between the cache and the database. The cache-aside strategy will be used, with artifact caches having a 14-day expiration.</technical_details>
      <affected_components>
        <component>LAPS Core Service</component>
        <component>Cache Manager</component>
        <component>Artifact Processing Layer</component>
        <component>Artifact Types Layer</component>
      </affected_components>
    </epic>
    <tickets>
      <ticket>
        <title>Set up Redis Cache for LAPS</title>
        <user_story>As a LAPS developer, I want to set up and integrate Redis cache with LAPS so that we have a foundation for implementing caching strategies.</user_story>
        <acceptance_criteria>
          <criterion>Redis client is successfully configured and connected to LAPS</criterion>
          <criterion>Cache manager is implemented with basic CRUD operations</criterion>
          <criterion>Cache operations are logged for monitoring purposes</criterion>
          <criterion>Unit tests are written for cache manager operations</criterion>
        </acceptance_criteria>
        <description>Configure and integrate Redis cache with LAPS, including setting up the Redis client and implementing a cache manager to handle cache operations.</description>
        <affected_files>
          <file>src/utils/cache-manager.ts</file>
          <file>src/plugins/laps.plugin.ts</file>
          <file>src/services/artifact.service.ts</file>
          <file>src/services/artifact-type.service.ts</file>
          <file>test/unit/cache-manager.test.ts</file>
          <file>test/integration/laps-cache.test.ts</file>
        </affected_files>
        <steps>
          <step>Install and configure ioredis library</step>
          <step>Create CacheManager class with CRUD operations</step>
          <step>Implement error handling and logging in CacheManager</step>
          <step>Update LAPS plugin to include CacheManager</step>
          <step>Inject CacheManager into relevant services</step>
          <step>Implement logging for cache operations</step>
          <step>Create Splunk dashboard for cache monitoring</step>
          <step>Write unit and integration tests</step>
        </steps>
        <dependencies>None</dependencies>
        <risks_and_challenges>Ensuring proper error handling and fallback mechanisms if Redis connection fails</risks_and_challenges>
        <estimated_complexity>Medium</estimated_complexity>
        <priority>High</priority>
        <effort>13</effort>
        <effortIn>story points</effortIn>
      </ticket>
      <ticket>
        <title>Implement Artifact Type Caching</title>
        <user_story>As a LAPS developer, I want to implement caching for artifact types so that we can retrieve them faster and reduce database load.</user_story>
        <acceptance_criteria>
          <criterion>Artifact types are cached in the specified JSON structure</criterion>
          <criterion>Cache is updated when artifact types are created, updated, or deleted</criterion>
          <criterion>Artifact type retrieval prioritizes cache over database queries</criterion>
          <criterion>Cache and database remain consistent after CRUD operations</criterion>
          <criterion>Performance improvement in artifact type retrieval is measurable</criterion>
        </acceptance_criteria>
        <description>Implement caching for artifact types using a specific JSON structure to improve retrieval speed and reduce database load. Ensure cache consistency with database operations.</description>
        <affected_files>
          <file>src/services/artifact-type.service.ts</file>
          <file>src/models/artifact-type.model.ts</file>
          <file>src/controllers/artifact-type.controller.ts</file>
          <file>test/unit/artifact-type-service.test.ts</file>
          <file>test/integration/artifact-type-cache.test.ts</file>
          <file>test/performance/artifact-type-retrieval.test.ts</file>
        </affected_files>
        <steps>
          <step>Design and implement the cache structure for artifact types</step>
          <step>Update ArtifactTypeService to use CacheManager</step>
          <step>Implement conversion methods between DB model and cache structure</step>
          <step>Update CRUD operations to maintain cache-database consistency</step>
          <step>Implement performance optimizations for batch operations</step>
          <step>Update API endpoints to use new caching mechanism</step>
          <step>Write unit, integration, and performance tests</step>
          <step>Update documentation for artifact type caching</step>
        </steps>
        <dependencies>Set up Redis Cache</dependencies>
        <risks_and_challenges>Ensuring cache consistency with database during concurrent operations</risks_and_challenges>
        <estimated_complexity>High</estimated_complexity>
        <priority>High</priority>
        <effort>21</effort>
        <effortIn>story points</effortIn>
      </ticket>
      <ticket>
        <title>Implement Artifact Caching</title>
        <user_story>As a LAPS developer, I want to implement caching for processed artifacts so that we can retrieve them quickly and reduce processing overhead.</user_story>
        <acceptance_criteria>
          <criterion>Processed artifacts are cached with a 14-day expiration</criterion>
          <criterion>Cache-aside strategy is correctly implemented for artifacts</criterion>
          <criterion>Artifact retrieval prioritizes cache over database queries</criterion>
          <criterion>Cache is properly updated when artifacts are created or modified</criterion>
          <criterion>Expired cache entries are handled correctly</criterion>
          <criterion>Performance improvement in artifact retrieval is measurable</criterion>
        </acceptance_criteria>
        <description>Implement caching for processed artifacts using a cache-aside strategy with a 14-day expiration period. This will improve retrieval speed and reduce processing overhead for frequently accessed artifacts.</description>
        <affected_files>
          <file>src/services/artifact.service.ts</file>
          <file>src/models/artifact.model.ts</file>
          <file>src/controllers/artifact.controller.ts</file>
          <file>src/utils/cache-manager.ts</file>
          <file>test/unit/artifact-service.test.ts</file>
          <file>test/integration/artifact-cache.test.ts</file>
          <file>test/performance/artifact-retrieval.test.ts</file>
        </affected_files>
        <steps>
          <step>Design and implement the cache structure for artifacts</step>
          <step>Update ArtifactService to use CacheManager with cache-aside strategy</step>
          <step>Implement CRUD operations with caching and 14-day expiration</step>
          <step>Develop expiration handling mechanism</step>
          <step>Implement bulk artifact caching operations</step>
          <step>Update API endpoints to use new caching mechanism</step>
          <step>Write unit, integration, and performance tests</step>
          <step>Implement monitoring for cache performance</step>
          <step>Update documentation for artifact caching</step>
        </steps>
        <dependencies>Set up Redis Cache</dependencies>
        <risks_and_challenges>Managing cache size and preventing cache overflow with large numbers of artifacts</risks_and_challenges>
        <estimated_complexity>Medium</estimated_complexity>
        <priority>High</priority>
        <effort>17</effort>
        <effortIn>story points</effortIn>
      </ticket>
    </tickets>
  </epic_and_tickets>
  <epic_and_tickets>
    <epic>
      <title>Database Schema Update for Artifact Type Management</title>
      <user_story>As a developer, I want to update the LAPS database schema to support new artifact type management so that we can implement flexible artifact processing and improve system extensibility.</user_story>
      <description>This epic involves updating the LAPS database schema to support new artifact type management. It includes creating new tables, modifying existing tables, and defining new enums to enable more flexible and extensible artifact processing.</description>
      <technical_details>The schema update will involve creating 9 new tables, modifying the existing artifacts table, and defining 4 new enum types. This will require careful consideration of data relationships, indexing for performance, and ensuring backwards compatibility with existing data.</technical_details>
      <affected_components>
        <component>LAPS Database</component>
        <component>ORM Models</component>
        <component>Database Migration Scripts</component>
      </affected_components>
    </epic>
    <tickets>
      <ticket>
        <title>Create New Tables for Artifact Type Management</title>
        <user_story>As a database administrator, I want to create new tables to support artifact type management so that we can store and manage artifact types, workflows, and their relationships efficiently.</user_story>
        <acceptance_criteria>
          <criterion>All 9 new tables are created in the database with correct columns, data types, and constraints</criterion>
          <criterion>Appropriate indexes are created for performance optimization</criterion>
          <criterion>The new tables can be queried and manipulated without errors</criterion>
          <criterion>The table creation script is idempotent and can be run multiple times without error</criterion>
        </acceptance_criteria>
        <description>Create 9 new tables in the LAPS database to support artifact type management. These tables will store information about artifact groups, workflows, artifact types, and their relationships.</description>
        <affected_files>
          <file>schema/sql/V2024_05_28__add_artifact_type_tables.sql</file>
          <file>src/orm/models/artifact-group/model.ts</file>
          <file>src/orm/models/workflow-name/model.ts</file>
          <file>src/orm/models/artifact-type/model.ts</file>
          <file>src/orm/models/journey/model.ts</file>
        </affected_files>
        <steps>
          <step>Create SQL script for table creation</step>
          <step>Add CREATE TABLE statements for each new table</step>
          <step>Define foreign key constraints</step>
          <step>Create necessary indexes</step>
          <step>Test the script in a development environment</step>
          <step>Create corresponding ORM models for new tables</step>
          <step>Update existing ORM models if necessary</step>
          <step>Write and run tests for new ORM models</step>
        </steps>
        <dependencies>None</dependencies>
        <risks_and_challenges>Ensuring backwards compatibility with existing data and queries. Performance impact of new tables and relationships.</risks_and_challenges>
        <estimated_complexity>High</estimated_complexity>
        <priority>High</priority>
        <effort>13</effort>
        <effortIn>story points</effortIn>
      </ticket>
      <ticket>
        <title>Update Artifacts Table with Applicant Role</title>
        <user_story>As a database administrator, I want to add an applicant_role column to the artifacts table so that we can associate artifacts with specific applicant types.</user_story>
        <acceptance_criteria>
          <criterion>The artifacts table has a new applicant_role column</criterion>
          <criterion>The applicant_role column accepts valid enum values</criterion>
          <criterion>Existing queries and operations on the artifacts table continue to work</criterion>
          <criterion>The table alteration script is idempotent</criterion>
        </acceptance_criteria>
        <description>Modify the existing artifacts table to include a new applicant_role column. This will allow artifacts to be associated with specific applicant types (e.g., primary, cosigner).</description>
        <affected_files>
          <file>schema/sql/V2024_05_29__add_applicant_role_to_artifacts.sql</file>
          <file>src/orm/models/artifact/model.ts</file>
          <file>src/orm/repositories/artifact/repository.ts</file>
        </affected_files>
        <steps>
          <step>Create SQL script for altering the artifacts table</step>
          <step>Add ALTER TABLE statement to add applicant_role column</step>
          <step>Create CHECK constraint for valid enum values</step>
          <step>Create index on applicant_role column</step>
          <step>Update Artifact ORM model</step>
          <step>Update relevant repository methods and queries</step>
          <step>Write and run tests for updated model and queries</step>
        </steps>
        <dependencies>None</dependencies>
        <risks_and_challenges>Potential impact on existing queries and data integrity. Ensuring all code that interacts with the artifacts table is updated.</risks_and_challenges>
        <estimated_complexity>Medium</estimated_complexity>
        <priority>High</priority>
        <effort>5</effort>
        <effortIn>story points</effortIn>
      </ticket>
      <ticket>
        <title>Create Enums for Artifact Type Management</title>
        <user_story>As a developer, I want to create database enums for event types, artifact holders, filters, and applicant types so that we can ensure data consistency and improve query performance for these frequently used values.</user_story>
        <acceptance_criteria>
          <criterion>Four new enum types are created in the database: event_types, artifact_holder, filters, and applicant_type</criterion>
          <criterion>Each enum type contains all the specified values from the TDD</criterion>
          <criterion>The enums can be used in table column definitions and constraints</criterion>
          <criterion>The enum creation script is idempotent</criterion>
        </acceptance_criteria>
        <description>Define four new enum types in the database to represent event types, artifact holders, filters, and applicant types. These enums will be used in various tables to ensure data consistency and improve query performance.</description>
        <affected_files>
          <file>schema/sql/V2024_05_30__create_artifact_management_enums.sql</file>
          <file>src/orm/enums.ts</file>
          <file>src/orm/models/artifact-type-source/model.ts</file>
          <file>src/orm/models/artifact/model.ts</file>
        </affected_files>
        <steps>
          <step>Create SQL script for enum creation</step>
          <step>Add CREATE TYPE statements for each enum</step>
          <step>Update relevant table columns to use new enum types</step>
          <step>Create TypeScript enum definitions in src/orm/enums.ts</step>
          <step>Update affected ORM models to use new enum types</step>
          <step>Write and run tests for updated models and enum usage</step>
        </steps>
        <dependencies>None</dependencies>
        <risks_and_challenges>Ensuring all existing data conforms to the new enum types. Updating all code that interacts with these fields to use the new enum types.</risks_and_challenges>
        <estimated_complexity>Medium</estimated_complexity>
        <priority>High</priority>
        <effort>8</effort>
        <effortIn>story points</effortIn>
      </ticket>
    </tickets>
  </epic_and_tickets>
  <epic_and_tickets>
    <epic>
      <title>Retool Integration for Self-Service Artifact Type Management</title>
      <user_story>As a product team member, I want to manage artifact types and catalog components through a user-friendly interface so that I can efficiently configure and maintain the lending artifact processing system without relying on engineering intervention.</user_story>
      <description>Develop a Retool application that provides a self-service interface for managing artifact types and catalog components in the Lending Artifact Processing Service (LAPS). This will enable product teams to create, read, update, and delete artifact types and catalog components, reducing the time required for adding new artifacts from one sprint to one day.</description>
      <technical_details>The Retool application will interface with the LAPS backend through newly developed RESTful APIs. It will require S2S authentication for secure communication. The application will manage artifact types and catalog components (workflow names, artifact groups, and journeys) stored in the LAPS database and cache.</technical_details>
      <affected_components>
        <component>Retool Application</component>
        <component>LAPS API</component>
        <component>LAPS Database</component>
        <component>Redis Cache</component>
      </affected_components>
    </epic>
    <tickets>
      <ticket>
        <title>Design Artifact Type Management UI</title>
        <user_story>As a product team member, I want a user-friendly interface to manage artifact types so that I can easily create, view, update, and delete artifact configurations.</user_story>
        <acceptance_criteria>
          <criterion>A form is available for creating and editing artifact types with all required fields</criterion>
          <criterion>Validation is implemented for all required fields</criterion>
          <criterion>A list view of existing artifact types is available with search functionality</criterion>
          <criterion>Users can delete artifact types with a confirmation prompt</criterion>
        </acceptance_criteria>
        <description>Create a Retool interface for managing artifact types, including forms for CRUD operations and a list view for existing artifact types.</description>
        <affected_files>
          <file>New Retool application files</file>
        </affected_files>
        <steps>
          <step>Create new Retool page for Artifact Type Management</step>
          <step>Design and implement the artifact type form</step>
          <step>Create the artifact type list view</step>
          <step>Implement CRUD operations and connect to LAPS API</step>
          <step>Add validation, error handling, and success messages</step>
          <step>Test the UI thoroughly</step>
        </steps>
        <dependencies>LAPS API endpoints for artifact type management</dependencies>
        <risks_and_challenges>Ensuring all required fields are properly validated and mapped to the API request structure</risks_and_challenges>
        <estimated_complexity>Medium</estimated_complexity>
        <priority>High</priority>
        <effort>13</effort>
        <effortIn>story points</effortIn>
      </ticket>
      <ticket>
        <title>Design Catalog Management UI</title>
        <user_story>As a product team member, I want to manage catalog components (workflow names, artifact groups, and journeys) so that I can maintain the necessary metadata for artifact types.</user_story>
        <acceptance_criteria>
          <criterion>Separate views are available for workflow names, artifact groups, and journeys</criterion>
          <criterion>CRUD operations are supported for each catalog component type</criterion>
          <criterion>List views with search functionality are available for each component type</criterion>
          <criterion>Validation is implemented for all required fields</criterion>
        </acceptance_criteria>
        <description>Create Retool interfaces for managing catalog components, including workflow names, artifact groups, and journeys.</description>
        <affected_files>
          <file>New Retool application files</file>
        </affected_files>
        <steps>
          <step>Create new Retool pages for Workflow Names, Artifact Groups, and Journeys</step>
          <step>Design and implement forms for each component type</step>
          <step>Create list views for each component type</step>
          <step>Implement CRUD operations and connect to LAPS API</step>
          <step>Add validation, error handling, and success messages</step>
          <step>Test each component management interface thoroughly</step>
        </steps>
        <dependencies>LAPS API endpoints for catalog component management</dependencies>
        <risks_and_challenges>Maintaining consistency across the three different catalog component interfaces while handling their unique requirements</risks_and_challenges>
        <estimated_complexity>Medium</estimated_complexity>
        <priority>High</priority>
        <effort>13</effort>
        <effortIn>story points</effortIn>
      </ticket>
      <ticket>
        <title>Configure API Connections in Retool</title>
        <user_story>As a Retool developer, I want to set up secure connections to LAPS API endpoints so that the Retool application can communicate with the backend services.</user_story>
        <acceptance_criteria>
          <criterion>LAPS API resource is configured in Retool with the correct base URL</criterion>
          <criterion>S2S authentication is properly set up for API calls</criterion>
          <criterion>Test queries successfully retrieve data from LAPS API endpoints</criterion>
          <criterion>API connections are secured and follow Earnest&apos;s security guidelines</criterion>
        </acceptance_criteria>
        <description>Configure and test API connections between the Retool application and LAPS backend services, ensuring secure communication using S2S authentication.</description>
        <affected_files>
          <file>Retool API resource configuration</file>
          <file>Retool environment variables</file>
        </affected_files>
        <steps>
          <step>Create LAPS API resource in Retool</step>
          <step>Configure S2S authentication for the API resource</step>
          <step>Create and test queries for each LAPS API endpoint</step>
          <step>Implement error handling for API connections</step>
          <step>Set up access controls for the API resource</step>
          <step>Document the API configuration process</step>
        </steps>
        <dependencies>LAPS API implementation and S2S token generation</dependencies>
        <risks_and_challenges>Ensuring secure handling of S2S tokens and proper access controls in Retool</risks_and_challenges>
        <estimated_complexity>Low</estimated_complexity>
        <priority>High</priority>
        <effort>5</effort>
        <effortIn>story points</effortIn>
      </ticket>
      <ticket>
        <title>Implement Data Binding in Retool</title>
        <user_story>As a Retool developer, I want to bind UI components to API data so that users can interact with LAPS data through the Retool interface.</user_story>
        <acceptance_criteria>
          <criterion>All form fields are correctly mapped to API request structures</criterion>
          <criterion>API response data is properly displayed in list views</criterion>
          <criterion>Error messages from API responses are displayed to users</criterion>
          <criterion>Success messages are shown for successful CRUD operations</criterion>
        </acceptance_criteria>
        <description>Implement data binding between Retool UI components and LAPS API data, including proper handling of API requests, responses, and error conditions.</description>
        <affected_files>
          <file>Retool application files (all pages)</file>
        </affected_files>
        <steps>
          <step>Map form fields to API request structures for each page</step>
          <step>Create and configure CRUD queries for each data type</step>
          <step>Bind table components to API response data</step>
          <step>Implement error handling and success messages</step>
          <step>Add data refresh logic for CRUD operations</step>
          <step>Implement loading states and client-side validation</step>
          <step>Test data binding thoroughly for all operations</step>
        </steps>
        <dependencies>Completed API connection configuration, UI design implementation</dependencies>
        <risks_and_challenges>Handling complex data structures and ensuring consistent error handling across all operations</risks_and_challenges>
        <estimated_complexity>Medium</estimated_complexity>
        <priority>High</priority>
        <effort>13</effort>
        <effortIn>story points</effortIn>
      </ticket>
    </tickets>
  </epic_and_tickets>
</epics>
